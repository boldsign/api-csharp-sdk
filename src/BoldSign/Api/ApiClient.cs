/*
 * BoldSign API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1
 *
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

namespace BoldSign.Api
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Net.Http.Headers;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Threading.Tasks;
    using System.Web;
    using BoldSign.Api.Extensions;
    using BoldSign.Api.Model;
    using BoldSign.Api.Resources;
    using BoldSign.Model;
    using Newtonsoft.Json;

    /// <summary>
    ///     API client is mainly responsible for making the HTTP call to the API backend.
    /// </summary>
    public class ApiClient
    {
        #region Constants

        /// <summary>
        ///     X-API-KEY for ApiKey.
        /// </summary>
        /// <value>X-API-KEY for ApiKey.</value>
        public const string XApiKey = "X-API-KEY";

        #endregion Constants

        private readonly JsonSerializerSettings serializerSettings = new JsonSerializerSettings
        {
            ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor,
        };
        private List<HttpMethod> noContentMethods = new List<HttpMethod>
        {
            HttpMethod.Get,
            HttpMethod.Head,
            HttpMethod.Delete,
        };
        private HttpClient httpClient;

        /// <summary>
        ///     Initializes a new instance of the <see cref="ApiClient" /> class
        ///     with default configuration.
        /// </summary>
        public ApiClient()
        {
            this.Configuration = Api.Configuration.Default;
            this.HttpClient = new HttpClient();
            this.HttpClient.BaseAddress = new Uri(this.Configuration.BasePath);
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="ApiClient" /> class
        ///     with default base path <see cref="Api.Configuration.ApiBaseUrl"/>.
        /// </summary>
        /// <param name="config">An instance of Configuration.</param>
        public ApiClient(Configuration config)
        {
            this.Configuration = config ?? Api.Configuration.Default;

            this.HttpClient = new HttpClient();
            this.HttpClient.BaseAddress = new Uri(this.Configuration.BasePath);
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="ApiClient" /> class
        /// </summary>
        /// <param name="basePath">An instance of base path.</param>
        /// <param name="apiKey">An instance of api key.</param>
        public ApiClient(string basePath, string apiKey)
        {
            if (string.IsNullOrEmpty(basePath))
            {
                throw new ArgumentException("basePath cannot be empty");
            }
            this.HttpClient = new HttpClient();
            this.HttpClient.BaseAddress = new Uri(basePath);
            this.Configuration = Api.Configuration.Default;
            this.Configuration.DefaultHeader.Remove(XApiKey);
            this.Configuration.DefaultHeader.Add(XApiKey, apiKey);
        }

        private string m_apiKey;
        /// <summary>
        ///     Initializes a new instance of the <see cref="ApiClient" /> class
        /// </summary>
        /// <param name="apiKey">An instance of Configuration.</param>
        public string ApiKey
        {
            get => m_apiKey;
            set
            {
                if (m_apiKey != value)
                {
                    this.m_apiKey = value;
                    this.Configuration.DefaultHeader.Remove(XApiKey);
                    this.Configuration.DefaultHeader.Add(XApiKey, m_apiKey);
                }
            }
        }


        /// <summary>
        ///     Initializes a new instance of the <see cref="ApiClient" /> class
        ///     with default configuration.
        /// </summary>
        /// <param name="basePath">The base path.</param>
        public ApiClient(string basePath = Api.Configuration.ApiBaseUrl)
        {
            if (string.IsNullOrEmpty(basePath))
            {
                throw new ArgumentException("basePath cannot be empty");
            }

            this.HttpClient = new HttpClient();
            this.HttpClient.BaseAddress = new Uri(basePath);
            this.Configuration = Api.Configuration.Default;
        }

        /// <summary>
        ///     Gets or sets an instance of the IReadableConfiguration.
        /// </summary>
        /// <value>An instance of the IReadableConfiguration.</value>
        /// <remarks>
        ///     <see cref="IReadableConfiguration" /> helps us to avoid modifying possibly global
        ///     configuration values from within a given client. It does not guarantee thread-safety
        ///     of the <see cref="Configuration" /> instance in any way.
        /// </remarks>
        public IReadableConfiguration Configuration { get; set; }

        /// <summary>
        ///     Gets or sets the HttpClient.
        /// </summary>
        /// <value>An instance of the HttpClient.</value>
        internal HttpClient HttpClient
        {
            get => this.httpClient ?? new HttpClient();
            set => this.httpClient = value;
        }

        // Creates and sets up a RestRequest prior to a call.
        /// <summary>
        ///  Creates and sets up a RestRequest prior to a call.
        /// </summary>
        /// <param name="path">Gets or sets a path.</param>
        /// <param name="method">Gets or sets a method.</param>
        /// <param name="queryParams">Gets or sets a queryParams.</param>
        /// <param name="postBody">Gets or sets a postBody.</param>
        /// <param name="headerParams">Gets or sets a headerParams.</param>
        /// <param name="formParams">Gets or sets a formParams.</param>
        /// <param name="fileParams">Gets or sets a fileParams.</param>
        /// <param name="contentType">Gets or sets a contentType.</param>
        /// <param name="fileUrlsParams">Gets or sets a fileUrlParams.</param>>
        /// <param name="singleFileParam">Gets or sets a singleFileParam.</param>>
        /// <returns>request.</returns>
        internal HttpRequestMessage PrepareRequest(string path, HttpMethod method, List<KeyValuePair<string, string>> queryParams, object postBody, Dictionary<string, string> headerParams, Dictionary<string, string> formParams, Dictionary<string, List<IDocumentFile>> fileParams, string contentType, Dictionary<string, Uri> fileUrlsParams, KeyValuePair<string, IImageFile> singleFileParam)
        {
            var pathUrl = BuildUri(path, queryParams);
            var request = new HttpRequestMessage(method, pathUrl);
            var form = new MultipartFormDataContent();

            // add header parameter, if any
            foreach (var param in headerParams)
            {
                request.Headers.Add(param.Key, param.Value);
            }

            // add form parameter, if any
            foreach (var param in formParams)
            {
                form.AddFormParameter(param.Key, param.Value);
            }

            // add file parameter, if any
            foreach (var param in fileParams)
            {
                foreach (var file in param.Value)
                {
                    if (file is DocumentFilePath documentFilePath)
                    {
                        var content = GetDocumentFromFilePath(documentFilePath);
                        var fileContent = new ByteArrayContent(content);
                        fileContent.Headers.ContentType = MediaTypeHeaderValue.Parse(documentFilePath.ContentType);
                        var fileName = Path.GetFileName(documentFilePath.FilePath);
                        form.Add(fileContent, param.Key, fileName);
                    }
                    else
                    {
                        var documentFile = GetDocumentFileWithValidation(file);

                        var byteArrayContent = new ByteArrayContent(documentFile.FileData);
                        byteArrayContent.Headers.ContentType = MediaTypeHeaderValue.Parse(documentFile.ContentType);
                        form.Add(byteArrayContent, param.Key, documentFile.FileName);
                    }
                }
            }

            if (!string.IsNullOrEmpty(singleFileParam.Key))
            {
                var key = singleFileParam.Key;
                if (singleFileParam.Value == null)
                {
                    throw new ApiException((int)HttpStatusCode.BadRequest, string.Format(CultureInfo.CurrentCulture, ApiValidationMessages.EmptyFields, singleFileParam.Key));
                }

                switch (singleFileParam.Value)
                {
                    case ImageFileStream brandingFileStream:
                        {
                            HandleFileStream(brandingFileStream, key, form);
                            break;
                        }

                    case ImageFileBytes brandingFileBytes:
                        {
                            HandleFileBytes(brandingFileBytes, key, form);
                            break;
                        }

                    case ImageFilePath brandingFilePath:
                        {
                            HandleFilePath(brandingFilePath, key, form);
                            break;
                        }

                    default:
                        {
                            throw new InvalidOperationException(ApiValidationMessages.InvalidBrandFileInstance);
                        }
                }
            }

            // add file URL parameter, if any
            foreach (var param in fileUrlsParams)
            {
                form.AddFormParameter(param.Key, param.Value?.AbsoluteUri);
            }

            // http body (model or byte[]) parameter
            if (postBody != null)
            {
                var requestBodyContent = new StringContent(postBody.ToString(), Encoding.UTF8, contentType);
                request.Content = requestBodyContent;
                return request;
            }

            if (!this.noContentMethods.Contains(method) && form.Any())
            {
                request.Content = form;
            }

            return request;
        }

        internal static byte[] GetDocumentFromFilePath(DocumentFilePath documentFilePath)
        {
            if (string.IsNullOrEmpty(documentFilePath.FilePath))
            {
                throw new ApiException(400, string.Format(CultureInfo.CurrentCulture, ApiValidationMessages.EmptyFields, nameof(documentFilePath.FilePath)));
            }

            if (string.IsNullOrEmpty(documentFilePath.ContentType))
            {
                throw new ApiException(422, ApiValidationMessages.UnsupportedFileType);
            }

            var content = File.ReadAllBytes(documentFilePath.FilePath);

            return content;
        }

        internal static DocumentFile GetDocumentFileWithValidation(IDocumentFile file)
        {
            var documentFile = GetDocumentFile(file);
            if (string.IsNullOrEmpty(documentFile.FileName))
            {
                throw new ApiException(400, string.Format(CultureInfo.CurrentCulture, ApiValidationMessages.EmptyFields, nameof(documentFile.FileName)));
            }

            if (string.IsNullOrEmpty(documentFile.ContentType))
            {
                throw new ApiException(422, ApiValidationMessages.UnsupportedFileType);
            }

            return documentFile;
        }

        internal static T HandleJsonFileParams<T>(IDocumentUpload documentUpload, T documentUploadJson)
            where T : IDocumentUploadJson
        {
            if (documentUpload == null || documentUploadJson == null)
            {
                return documentUploadJson;
            }

            documentUploadJson.Files = new List<string>();
            documentUploadJson.FileUrls = new List<Uri>();

            foreach (var file in documentUpload.Files ?? new List<IDocumentFile>())
            {
                string base64String;
                string contentType;

                if (file is DocumentFilePath documentFilePath)
                {
                    var content = GetDocumentFromFilePath(documentFilePath);

                    base64String = Convert.ToBase64String(content);
                    contentType = documentFilePath.ContentType;
                }
                else
                {
                    var documentFile = GetDocumentFileWithValidation(file);

                    base64String = Convert.ToBase64String(documentFile.FileData);
                    contentType = documentFile.ContentType;
                }

                // data:application/{{fileType}};base64,{{content}}
                var dataUri = $"data:{contentType};base64,{base64String}";
                documentUploadJson.Files.Add(dataUri);
            }

            documentUploadJson.FileUrls.AddRange(documentUpload.FileUrls ?? new List<Uri>());

            return documentUploadJson;
        }

        /// <summary>
        /// Gets the document file from <see cref="IDocumentFile"/>.
        /// </summary>
        /// <param name="documentFile">The document file.</param>
        /// <returns>A DocumentFile.</returns>
        private static DocumentFile GetDocumentFile(IDocumentFile documentFile)
        {
            if (documentFile is DocumentFileBytes fileBytes)
            {
                return new DocumentFile
                {
                    FileData = fileBytes.FileData,
                    ContentType = fileBytes.ContentType,
                    FileName = fileBytes.FileName,
                };
            }
            else if (documentFile is DocumentFileStream documentFileStream)
            {
                var bytes = documentFileStream.FileData.ReadAsBytes();
                return new DocumentFile
                {
                    ContentType = documentFileStream.ContentType,
                    FileData = bytes,
                    FileName = documentFileStream.FileName,
                };
            }

            throw new InvalidOperationException($"{nameof(IDocumentFile)} is not parameter is not any of the actual derived type.");
        }

        /// <summary>
        ///     Makes the HTTP request (Sync).
        /// </summary>
        /// <param name="path">URL path.</param>
        /// <param name="method">HTTP method.</param>
        /// <param name="queryParams">Query parameters.</param>
        /// <param name="postBody">HTTP body (POST request).</param>
        /// <param name="headerParams">Header parameters.</param>
        /// <param name="formParams">Form parameters.</param>
        /// <param name="fileParams">File parameters.</param>
        /// <param name="contentType">Gets or sets a contentType.</param>
        /// <param name="fileUrlParams">File URL parameter.</param>
        /// <param name="singleFileParam">Single file parameter.</param>
        /// <returns>Object.</returns>
        internal HttpResponseMessage CallApi(string path, HttpMethod method, List<KeyValuePair<string, string>> queryParams, object postBody, Dictionary<string, string> headerParams, Dictionary<string, string> formParams, Dictionary<string, List<IDocumentFile>> fileParams, string contentType, Dictionary<string, Uri> fileUrlParams, KeyValuePair<string, IImageFile> singleFileParam = default)
        {
            using var request = this.PrepareRequest(path, method, queryParams, postBody, headerParams, formParams, fileParams, contentType, fileUrlParams, singleFileParam);

            // set user agent
            if (this.HttpClient.DefaultRequestHeaders.UserAgent.Count == 0)
            {
                this.HttpClient.DefaultRequestHeaders.UserAgent.ParseAdd(this.Configuration.UserAgent);
            }

            this.InterceptRequest();
            var response = this.HttpClient.SendAsync(request).GetAwaiter().GetResult();
            this.InterceptResponse();

            return response;
        }

        /// <summary>
        ///     Makes the asynchronous HTTP request.
        /// </summary>
        /// <param name="path">URL path.</param>
        /// <param name="method">HTTP method.</param>
        /// <param name="queryParams">Query parameters.</param>
        /// <param name="postBody">HTTP body (POST request).</param>
        /// <param name="headerParams">Header parameters.</param>
        /// <param name="formParams">Form parameters.</param>
        /// <param name="fileParams">File parameters.</param>
        /// <param name="contentType">Gets or sets a contentType.</param>
        /// <param name="fileUrlsParams">File Urls parameter.</param>
        /// <param name="singleFileParam">single file parameter.</param>
        /// <returns>The Task instance.</returns>
        internal async Task<HttpResponseMessage> CallApiAsync(string path, HttpMethod method, List<KeyValuePair<string, string>> queryParams, object postBody, Dictionary<string, string> headerParams, Dictionary<string, string> formParams, Dictionary<string, List<IDocumentFile>> fileParams, string contentType, Dictionary<string, Uri> fileUrlsParams, KeyValuePair<string, IImageFile> singleFileParam = default)
        {
            using var request = this.PrepareRequest(path, method, queryParams, postBody, headerParams, formParams, fileParams, contentType, fileUrlsParams, singleFileParam);
            if (this.HttpClient.DefaultRequestHeaders.UserAgent.Count == 0)
            {
                this.HttpClient.DefaultRequestHeaders.UserAgent.ParseAdd(this.Configuration.UserAgent);
            }

            this.InterceptRequest();
            var response = await this.HttpClient.SendAsync(request).ConfigureAwait(false);
            this.InterceptResponse();

            return response;
        }

        /// <summary>
        ///     Escape string (url-encoded).
        /// </summary>
        /// <param name="str">String to be escaped.</param>
        /// <returns>Escaped string.</returns>
        public string EscapeString(string str) => UrlEncode(str);

        /// <summary>
        ///     Allows for extending request processing for <see cref="ApiClient" /> generated code.
        /// </summary>
        private void InterceptRequest()
        {
            // Make this method partial, if extending or intercepting is required.
        }

        /// <summary>
        ///     Allows for extending response processing for <see cref="ApiClient" /> generated code.
        /// </summary>
        private void InterceptResponse()
        {
            // Make this method partial, if extending or intercepting is required.
        }

        /// <summary>
        ///     If parameter is DateTime, output in a formatted string (default ISO 8601), customizable with
        ///     Configuration.DateTime.
        ///     If parameter is a list, join the list with ",".
        ///     Otherwise just return the string.
        /// </summary>
        /// <param name="obj">The parameter (header, path, query, form).</param>
        /// <returns>Formatted string.</returns>
        internal string ParameterToString(object obj)
        {
            if (obj is DateTime)
            // Return a formatted date string - Can be customized with Configuration.DateTimeFormat
            // Defaults to an ISO 8601, using the known as a Round-trip date/time pattern ("o")
            // https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx#Anchor_8
            // For example: 2009-06-15T13:45:30.0000000
            {
                return ((DateTime)obj).ToString(this.Configuration.DateTimeFormat);
            }

            if (obj is DateTimeOffset)
            // Return a formatted date string - Can be customized with Configuration.DateTimeFormat
            // Defaults to an ISO 8601, using the known as a Round-trip date/time pattern ("o")
            // https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx#Anchor_8
            // For example: 2009-06-15T13:45:30.0000000
            {
                return ((DateTimeOffset)obj).ToString(this.Configuration.DateTimeFormat);
            }

            if (obj is bool)
            {
                return (bool)obj ? "true" : "false";
            }

            if (obj is IList)
            {
                var flattenedString = new StringBuilder();

                foreach (var param in (IList)obj)
                {
                    if (flattenedString.Length > 0)
                    {
                        flattenedString.Append(",");
                    }

                    flattenedString.Append(param);
                }

                return flattenedString.ToString();
            }

            return Convert.ToString(obj);
        }

        /// <summary>
        ///     Deserialize the JSON string into a proper object.
        /// </summary>
        /// <param name="response">The HTTP response.</param>
        /// <param name="type">Object type.</param>
        /// <returns>Object representation of the JSON string.</returns>
        internal object Deserialize(HttpResponseMessage response, Type type)
        {
            var headers = response.Headers;

            // return byte array
            if (type == typeof(byte[]))
            {
                var res = response.Content.ReadAsStringAsync().GetAwaiter().GetResult();
                return res;
            }

            // TODO: ? if (type.IsAssignableFrom(typeof(Stream)))
            if (type == typeof(Stream))
            {
                if (headers != null)
                {
                    var filePath = string.IsNullOrEmpty(this.Configuration.TempFolderPath)
                        ? Path.GetTempPath()
                        : this.Configuration.TempFolderPath;
                    var regex = new Regex(@"Content-Disposition=.*filename=['""]?([^'""\s]+)['""]?$");

                    foreach (var header in headers)
                    {
                        var match = regex.Match(header.ToString());

                        if (match.Success)
                        {
                            var fileName = filePath + SanitizeFilename(match.Groups[1].Value.Replace("\"", string.Empty).Replace("'", string.Empty));
                            File.WriteAllBytes(fileName, response.Content.ReadAsByteArrayAsync().GetAwaiter().GetResult());

                            return new FileStream(fileName, FileMode.Open);
                        }
                    }
                }

                var stream = new MemoryStream(response.Content.ReadAsByteArrayAsync().GetAwaiter().GetResult());

                return stream;
            }

            // return a datetime object
            if (type.Name.StartsWith("System.Nullable`1[[System.DateTime", StringComparison.CurrentCulture))
            {
                return DateTime.Parse(response.Content.ReadAsStringAsync().GetAwaiter().GetResult(), null, DateTimeStyles.RoundtripKind);
            }

            // return primitive type
            if (type == typeof(string) || type.Name.StartsWith("System.Nullable", StringComparison.CurrentCulture))
            {
                return ConvertType(response.Content, type);
            }

            // at this point, it must be a model (json)
            try
            {
                return JsonConvert.DeserializeObject(response.Content.ReadAsStringAsync().GetAwaiter().GetResult(), type, this.serializerSettings);
            }
            catch (Exception e)
            {
                throw new ApiException(500, e.Message);
            }
        }

        /// <summary>
        ///     Deserialize the JSON string into a proper object.
        /// </summary>
        /// <param name="json">The string content.</param>
        /// <returns>Object representation of the JSON string.</returns>
        internal T Deserialize<T>(string json)
        {
            try
            {
                return JsonConvert.DeserializeObject<T>(json, this.serializerSettings);
            }
            catch (Exception e)
            {
                throw new ApiException(500, e.Message);
            }
        }

        /// <summary>
        ///     Serialize an input (model) into JSON string
        /// </summary>
        /// <param name="obj">Object.</param>
        /// <returns>JSON string.</returns>
        internal string Serialize(object obj)
        {
            try
            {
                return obj != null ? JsonConvert.SerializeObject(obj) : null;
            }
            catch (Exception e)
            {
                throw new ApiException(500, e.Message);
            }
        }

        /// <summary>
        ///     Check if the given MIME is a JSON MIME.
        ///     JSON MIME examples:
        ///     application/json
        ///     application/json; charset=UTF8
        ///     APPLICATION/JSON
        ///     application/vnd.company+json
        /// </summary>
        /// <param name="mime">MIME</param>
        /// <returns>Returns True if MIME type is json.</returns>
        public bool IsJsonMime(string mime)
        {
            var jsonRegex = new Regex("(?i)^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$");

            return mime != null && (jsonRegex.IsMatch(mime) || mime.Equals("application/json-patch+json"));
        }

        /// <summary>
        ///     Select the Content-Type header's value from the given content-type array:
        ///     if JSON type exists in the given array, use it;
        ///     otherwise use the first one defined in 'consumes'
        /// </summary>
        /// <param name="contentTypes">The Content-Type array to select from.</param>
        /// <returns>The Content-Type header to use.</returns>
        internal string SelectHeaderContentType(string[] contentTypes)
        {
            if (contentTypes.Length == 0)
            {
                return "application/json";
            }

            foreach (var contentType in contentTypes)
            {
                if (this.IsJsonMime(contentType.ToLower()))
                {
                    return "application/json";
                }
            }

            return "application/json"; // use the first content type specified in 'consumes'
        }

        /// <summary>
        ///     Select the Accept header's value from the given accepts array:
        ///     if JSON exists in the given array, use it;
        ///     otherwise use all of them (joining into a string)
        /// </summary>
        /// <param name="accepts">The accepts array to select from.</param>
        /// <returns>The Accept header to use.</returns>
        internal string SelectHeaderAccept(string[] accepts)
        {
            if (accepts.Length == 0)
            {
                return null;
            }

            if (accepts.Contains("application/json", StringComparer.OrdinalIgnoreCase))
            {
                return "application/json";
            }

            return string.Join(",", accepts);
        }

        /// <summary>
        ///     Encode string in base64 format.
        /// </summary>
        /// <param name="text">String to be encoded.</param>
        /// <returns>Encoded string.</returns>
        private static string Base64Encode(string text) => Convert.ToBase64String(Encoding.UTF8.GetBytes(text));

        /// <summary>
        ///     Dynamically cast the object into target type.
        /// </summary>
        /// <param name="fromObject">Object to be casted</param>
        /// <param name="toObject">Target type</param>
        /// <returns>Casted object</returns>
        private static dynamic ConvertType(dynamic fromObject, Type toObject) => Convert.ChangeType(fromObject, toObject);

        /// <summary>
        ///     Convert stream to byte array
        /// </summary>
        /// <param name="inputStream">Input stream to be converted</param>
        /// <returns>Byte array</returns>
        private static byte[] ReadAsBytes(Stream inputStream)
        {
            var buf = new byte[16 * 1024];

            using (var ms = new MemoryStream())
            {
                int count;

                while ((count = inputStream.Read(buf, 0, buf.Length)) > 0)
                {
                    ms.Write(buf, 0, count);
                }

                return ms.ToArray();
            }
        }

        private static string BuildUri(string path, IEnumerable<KeyValuePair<string, string>> queryParams)
        {
            if (queryParams == null || !queryParams.Any())
            {
                return path;
            }

            var queryString = string.Join("&", queryParams.Select(x => $"{WebUtility.UrlEncode(x.Key)}={WebUtility.UrlEncode(x.Value)}"));
            return $"{path}?{queryString}";
        }

        /// <summary>
        ///     URL encode a string
        ///     Credit/Ref: https://github.com/restsharp/RestSharp/blob/master/RestSharp/Extensions/StringExtensions.cs#L50
        /// </summary>
        /// <param name="input">String to be URL encoded</param>
        /// <returns>Byte array</returns>
        private static string UrlEncode(string input)
        {
            const int maxLength = 32766;

            if (input == null)
            {
                throw new ArgumentNullException("input");
            }

            if (input.Length <= maxLength)
            {
                return Uri.EscapeDataString(input);
            }

            var sb = new StringBuilder(input.Length * 2);
            var index = 0;

            while (index < input.Length)
            {
                var length = Math.Min(input.Length - index, maxLength);
                var subString = input.Substring(index, length);

                sb.Append(Uri.EscapeDataString(subString));
                index += subString.Length;
            }

            return sb.ToString();
        }

        /// <summary>
        ///     Sanitize filename by removing the path
        /// </summary>
        /// <param name="filename">Filename</param>
        /// <returns>Filename</returns>
        private static string SanitizeFilename(string filename)
        {
            var match = Regex.Match(filename, @".*[/\\](.*)$");

            if (match.Success)
            {
                return match.Groups[1].Value;
            }

            return filename;
        }

        /// <summary>
        ///     Convert params to key/value pairs.
        ///     Use collectionFormat to properly format lists and collections.
        /// </summary>
        /// <param name="collectionFormat">Collection format.</param>
        /// <param name="name">Key name.</param>
        /// <param name="value">Value object.</param>
        /// <returns>A list of KeyValuePairs</returns>
        internal IEnumerable<KeyValuePair<string, string>> ParameterToKeyValuePairs(string collectionFormat, string name, object value)
        {
            var parameters = new List<KeyValuePair<string, string>>();

            if (IsCollection(value) && collectionFormat == "multi")
            {
                var valueCollection = value as IEnumerable;
                parameters.AddRange(from object item in valueCollection select new KeyValuePair<string, string>(name, this.ParameterToString(item)));
            }
            else
            {
                parameters.Add(new KeyValuePair<string, string>(name, this.ParameterToString(value)));
            }

            return parameters;
        }

        /// <summary>
        ///     Check if generic object is a collection.
        /// </summary>
        /// <param name="value"></param>
        /// <returns>True if object is a collection type</returns>
        private static bool IsCollection(object value) => value is IList || value is ICollection;

        private static void HandleFileBytes(ImageFileBytes brandLogoFileBytes, string key, MultipartFormDataContent form)
        {
            var fileBytes = brandLogoFileBytes.FileBytes;
            if (fileBytes == null)
            {
                throw new ApiException((int)HttpStatusCode.BadRequest, string.Format(CultureInfo.CurrentCulture, ApiValidationMessages.EmptyFields, nameof(brandLogoFileBytes.FileBytes)));
            }

            AddFileContentToForm(fileBytes, key, form);
        }

        private static void HandleFileStream(ImageFileStream documentFileStream, string key, MultipartFormDataContent form)
        {
            var fileStream = documentFileStream.FileStream;
            if (fileStream == null)
            {
                throw new ApiException((int)HttpStatusCode.BadRequest, string.Format(CultureInfo.CurrentCulture, ApiValidationMessages.EmptyFields, nameof(documentFileStream.FileStream)));
            }

            using var memoryStream = new MemoryStream();
            fileStream.CopyTo(memoryStream);

            AddFileContentToForm(memoryStream.ToArray(), key, form);
        }

        private static void HandleFilePath(ImageFilePath documentFilePath, string key, MultipartFormDataContent form)
        {
            // If FilePath is empty, throw an exception
            if (string.IsNullOrEmpty(documentFilePath.FilePath))
            {
                throw new ApiException((int)HttpStatusCode.BadRequest, string.Format(CultureInfo.CurrentCulture, ApiValidationMessages.EmptyFields, nameof(documentFilePath.FilePath)));
            }

            AddFileContentToForm(File.ReadAllBytes(documentFilePath.FilePath), key, form);
        }

        private static void AddFileContentToForm(byte[] fileBytes, string key, MultipartFormDataContent form)
        {
            var fileName = $"{GetExtension(fileBytes)}";
            var fileContent = new ByteArrayContent(fileBytes);
            fileContent.Headers.ContentDisposition = new ContentDispositionHeaderValue("form-data")
            {
                Name = key,
                FileName = fileName,
            };
            form.Add(fileContent);
        }

        private static string GetExtension(byte[] bytes)
        {
            if (IsPng(bytes))
            {
                return ".png";
            }
            else if (IsJpeg(bytes))
            {
                return ".jpeg";
            }
            else if (IsSvg(bytes))
            {
                return ".svg";
            }

            throw new ApiException((int)HttpStatusCode.BadRequest, ApiValidationMessages.UnsupportedBrandLogoType);
        }

        private static bool IsPng(byte[] fileBytes)
        {
            // PNG files start with the following bytes (magic number): 89 50 4E 47 0D 0A 1A 0A
            return fileBytes.Length >= 8 &&
                   fileBytes[0] == 0x89 &&
                   fileBytes[1] == 0x50 &&
                   fileBytes[2] == 0x4E &&
                   fileBytes[3] == 0x47 &&
                   fileBytes[4] == 0x0D &&
                   fileBytes[5] == 0x0A &&
                   fileBytes[6] == 0x1A &&
                   fileBytes[7] == 0x0A;
        }

        private static bool IsJpeg(byte[] fileBytes)
        {
            // JPEG or JPG files start with the following bytes (magic number): FF D8
            return fileBytes.Length >= 2 &&
                   fileBytes[0] == 255 && // JPEG signature
                   fileBytes[1] == 216;
        }

        private static bool IsSvg(byte[] fileBytes)
        {
            string fileHeader = Encoding.UTF8.GetString(fileBytes);
            return fileHeader.StartsWith("<?xml") || fileHeader.StartsWith("<svg");
        }
    }
}
